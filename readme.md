
########################
# Setup NIX environment
########################
    
    nix-shell --run $SHELL
    chmod +x setup.sh
    ./setup.sh
    source .env

Test that everything works:

    aws iam list-users
    docker ps
    kubectl get all -A

########################
# Crossplane Providers #
########################

Install the provider for AWS.

    cat providers/aws-s3.yaml
    kubectl apply --filename providers/aws-s3.yaml
    kubectl get pkgrev

Repeat the command until all providers are healthy.
Learn about Providers and ProviderFamilies.

    kubectl get pkgrev
    kubectl get crd | grep upbound.io

# Step 1 Basic Managed Resource

## step-1a 
Install some managed resources

    cat step1/step-1a.yaml
    kubectl apply -f step1/step-1a.yaml
    kubectl get managed

Check the status of the managed objects.
Check the logs of the provider pods.

Perform the final configuration of the provider

    cat providers/aws-config.yaml
    kubectl apply --filename providers/aws-config.yaml

    ./setups-creds.sh
    kubectl get secret aws-creds -n crossplane-system -o jsonpath='{.data.creds}' | base64 --decode
    
    kubectl get managed

Learn about how crossplane reconciles managed resources. See how native kubernetes concepts, spec, status and events
are used. Take a look at spec.status.atProvider.

Check the logs of the provider pods.

So the main takeaway here is that you describe your desired state in the spec.atProvider section and the actual state is
represented by spec.status.atProvider. As long as nothing is inherently wrong these should be pretty much the same.

## Step 1b

    diff step1/step-1a.yaml step1/step-1b.yaml
    cat step1/step-1b.yaml
    kubectl apply --filename step1/step-1b.yaml
    kubectl get managed

#####################################
# Step 2 Multiple managed resources #
#####################################

## Step 2a

    Add LifecyclePolicy to Bucket

## Step 2b

Lets make it more interesting by making a Lambda function.

Copy files to S3 bucket:

    aws s3 cp jokes/jokes_function.zip s3://timo-workshop-bucket/                                                                                                                                  â”‚
    aws s3 cp jokes/jokes.txt s3://timo-workshop-bucket/

Apply Lambda and Role

    cat step2/step-2b.yaml
    kubectl apply -f step2/step-2b.yaml
    kubectl get managed

Invoke the Lambda function:

    aws lambda invoke --function-name timo-workshop-lambda  --output json /dev/stdout | jq .body

## Step 2c

Use a label to attach the LifecyclePolicy to the bucket

    kubectl delete -f step2/step-2a.yaml
    diff step2/step-2a.yaml step2/step-2c.yaml
    kubectl apply -f step2/step-2c.yaml
    kubectl get managed

## Step 2d

Now as an exercise please do the same to the Lambda function and the role.

    cp step2/step-2b.yaml step2/step-2d.yaml
    kubectl delete -f step2/step-2b.yaml

Make your changes in `step2/step-2d.yaml` and:

    kubectl apply -f step2/step-2d.yaml

Lets talk building blocks.

## Delete Managed Resources

    kubectl delete -f step2/step-2a.yaml -f step2/step-2b.yaml

Now we now *everything there is to know* about managed resources and providers lets dive into XRD's and Composites
and Claims.

# Step 3 Lets make some compositions

## Step 3a - Trying to create a Custom Object

    kubectl apply -f step3/step3a.yaml

## Step 3b - Adding the CRD / XRD

    kubectl apply -f step3/step3b.yaml
    kubectl get bucket.workshop.tkp.nl

## Step 3c - Basic implementation (KCL)

    kubectl apply -f step3/step3c.yaml
    kubectl get function.pkg.crossplane.io -n crossplane-system
    kubectl get pod -n crossplane-system
    kubectl describe bucket.workshop.tkp.nl
    kubectl get managed
    kubectl get bucket.workshop.tkp.nl

## Step 3d - Auto Ready

    diff step3c.yaml step3d.yaml

    kubectl apply -f step3d.yaml
    kubectl get function.pkg.crossplane.io -n crossplane-system
    kubectl get pod -n crossplane-system
    kubectl get bucket.workshop.tkp.nl

## Step 3e - Controller Reference

    diff step3d.yaml step3e.yaml
    kubectl apply -f step3e.yaml
    kubectl get bucket.workshop.tkp.nl

Make sure the managed resources are generated by our composition

    kubectl delete -f step3a.yaml
    kubectl get managed
    kubectl apply -f step3a.yaml

    kubectl get bucketversioning.s3.aws.upbound.io/timo-workshop-bucket-versioning -o json | jq .status.atProvider

## Step 3f - Environment Config

    diff step3e.yaml step3f.yaml

## Step 3g - Creating the Claim

    crossplane beta trace bucket.workshop.tkp.nl/timo-workshop-bucket
    diff step3f.yaml step3g.yaml

    kubectl delete -f step3a.yaml
    kubectl apply -f step3g.yaml

    crossplane beta trace bucketclaim.workshop.tkp.nl/timo-workshop-bucket

#  Step 4 Now try the same for Role and Lambda

## What do we want to expose as an API?

## You make the implementation

##################################
# Composite Resource Definitions #
##################################

    cat compositions/sql-v1/definition.yaml
    kubectl apply --filename compositions/sql-v1/definition.yaml
    kubectl get compositeresourcedefinitions
    kubectl get xrds
    kubectl get crds | grep sql
    kubectl explain sqls.devopstoolkitseries.com --recursive

Learn about XRD's
Learn about CRD's

    cat examples/$HYPERSCALER-sql-v1.yaml
    kubectl apply --filename examples/$HYPERSCALER-sql-v1.yaml
    kubectl get sqls
    kubectl get managed
    kubectl get compositions

As you can see the above has no effect.


#########################
# Defining Compositions #
#########################

    cat compositions/sql-v1/$HYPERSCALER.yaml
    ls -1 compositions/sql-v1
    kubectl apply --filename compositions/sql-v1

Now lets see what is going on, i.e.:

    kubectl get managed

Any other commands?

    crossplane beta trace sql my-db

So lets fix it:

    cat providers/sql-v1.yaml
    kubectl apply --filename providers/sql-v1.yaml
    kubectl get pkgrev
    
    crossplane beta trace sql my-db
    crossplane beta trace sql my-db

#####################################
# Resource References and Selectors #
#####################################

Learn a bit about resource references: https://docs.crossplane.io/latest/concepts/compositions/#cross-resource-references

    cat compositions/sql-v1/$HYPERSCALER.yaml
    cat compositions/sql-v2/$HYPERSCALER.yaml
    kubectl apply --filename compositions/sql-v2

Delete the composition and watch the process

    kubectl delete --filename examples/$HYPERSCALER-sql-v1.yaml
    kubectl get managed


#############################
# Defining Composite Claims #
#############################

    cat compositions/sql-v5/definition.yaml
    cat compositions/sql-v6/$HYPERSCALER.yaml
    kubectl apply --filename compositions/sql-v6
    cat examples/$HYPERSCALER-sql-v6.yaml
    kubectl --namespace a-team apply --filename examples/$HYPERSCALER-sql-v6.yaml

Let's check it out:

    kubectl --namespace a-team get sqlclaims
    crossplane beta trace sqlclaim my-db --namespace a-team
    kubectl --namespace a-team get secrets


#########################
# Testing with Chainsaw #
#########################


######################
# Destroy Everything #
######################

    kubectl delete --namespace a-team sqlclaim/my-db 
    kubectl get managed
    kubectl patch database.postgresql.sql.crossplane.io $DB --patch '{"metadata":{"finalizers":[]}}' --type=merge
    exit